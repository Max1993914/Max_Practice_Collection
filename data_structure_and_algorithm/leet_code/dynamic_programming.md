# 动态规划(Dynamic Programming)


## 算法基本原理
如果说回溯算法是"一条道走到黑，不行再退回来"。动态规划就像是拥有上帝视角一样，一口气推演出所有可能的结果，然后选取最优。

动态规划算法会把问题分解为多个阶段，每个阶段都进行决策，并记录状态集合（去掉重复解），然后通过当前状态的集合，推导下一个阶段的状态集合。动态向前推进。

动态规划能解决的问题，大部分情况下回溯法都可以解决，但是回溯法的时间复杂度较高，动态规划相比之下效率高出不少，但是它也有自己的局限性：即要开辟额外的空间去记录状态。所以动态规划是一种典型的空间换时间的算法。

## 动态规划题目求解思路：

#### 什么样的题目适合使用动态规划来做？
1. 一个模型：多阶段决策最优解模型。即动态规划一般被用来解决最优问题，而解决问题的过程中有多个决策阶段，每个决策阶段对应一组状态，通过找寻一组决策序列产生最优解。
2. 三个特征：
    1. 最优子结构：通过前面的状态可以推出后面的状态。最优解势必包含子问题的某一个解。
    2. 无后效性：在推导后面的状态时，我们只关心前面状态的结果，不需要知道它是怎么得来的。并且它也不受后面决策的影响。
    3. 重复子问题：不同的决策序列，到达某一个阶段时可能得到相同的状态。
    
举例：
棋盘最短路径问题:
| 1 | 3 | 5 | 9 |  <br>
| 2 | 1 | 3 | 4 |  <br>
| 5 | 2 | 6 | 7 |  <br>
| 6 | 8 | 4 | 3 |  <br>

从左上角到右下角，每次只能向下或者向右走一格，问最短路径长度是多少？
状态设置为min_dist(i,j),表示到达i,j的最短路径。
一个模型：首先它是求最优解问题，其次它共有6步，每个阶段对应一个状态集合。
三个特征：
1. 从一个点到另一个点有多种走法，所以存在重复子问题min_dist(i,j)。
2. (i,j) 只关心(i, j-1) 和(i-1, j)两个点的结果，并且一旦决定，不会受到后面决策的影响。
3. (i, j)只能从(i, j-1), (i-1, j)得来，所以也可以说min_dist(i,j)是通过min_dist(i, j-1)和min_dist(i-1, j)推导出来的。
    
#### 动态规划的解题思路？
1. 状态转移方程 
   
    比如上面的min_dist(i, j) 是可以通过min_dist(i, j-1)和min_dist(i-1, j)推导出来的。动态转移方程：min_dist(i, j) = w[i][j] + min(min_dist(i-1, j), min_dist(i, j-1))

2. 状态转移表法
    
    首先考虑回溯法怎么解决，画出递归树。
   
    找出重复子问题，例如(i , j) = (1, 1)有两条路线可以到达，是重复子问题，但其实只要找到到达i,j的最短路径就好了，其他的节点可以舍弃。
   
    画一个状态表，一般状态表都是二维数组，包括行，列，以及它的值。如果问题更复杂，导致状态转移表的维度超过2维，就最好不用这种方式了，因为没法画出来，也不利于人脑去构思。

#### 与分治、回溯、贪心的区别
动态规划与贪心的区别在于，贪心算法属于一种特殊的动态规划，它实现起来更简单，但是可以解决的问题却更有限：它还要满足贪心选择性，即"通过最优局部解，可以产生全局最优解"。也就是说，贪心算法每一个阶段都会选取当前看来最优解，然后并由次可以获得全局最优解。
而动态规划不同，它的局部解并不一定是最优解，但最优解一定诞生于
