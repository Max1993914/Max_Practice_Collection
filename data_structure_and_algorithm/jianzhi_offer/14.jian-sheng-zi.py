"""
剪绳子
给你一根长度为 n 的绳子，请把绳子剪成整数长度的m段（m、n都是整数，n>1并且m>1），
每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？
例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18

思路：
动态规划
状态定义：dp[i]: 长度为i的绳子的最大乘积
状态转移方程：
初始化dp[0-n]都为0，dp[1] = 1, dp[2] = 1。
对于每一段长度i，都可以从不同地方下刀，截取的长度为j，那么切完一刀之后有两种情况：
    1. 不再切，则乘积为(i-j) * j
    2. 继续切，则乘积为dp[i-j] * j
    当然，j的长度也是一个变数，所以最终的转移方程为：dp[i] = max(dp[i], max((i-j) * j, dp[i-j] * j))
"""

def cut_rope(n):

    states = [0 for _ in range(n+1)]
    states[1] = 1
    states[2] = 1

    for i in range(3, n+1):
        for j in range(2, i):  # j为1没有意义，因为1*一个数还是那个数本身
            states[i] = max(states[i], max((i-j)*j, (states[i-j]*j)))
    return states[n]
